#pragma once

#include <iostream>
#include <ctime>
#include <string>
#include <vector>
#include <algorithm>
#include <sstream>
#include <memory>

#define GENERATE_ONLY_DIGITS

using std::cout;
using std::endl;
using std::shared_ptr;
using std::string;
using std::vector;

using uint = unsigned int;

class BinaryTree
{
private:
    struct Node
    {
        string value{""};

        // Points on left root of tree
        shared_ptr<Node> leftRoot;
        // Points on right root of tree
        shared_ptr<Node> rightRoot;

        explicit Node() : leftRoot(nullptr), rightRoot(nullptr) {}
        explicit Node(const string &value) : value(value), leftRoot(nullptr), rightRoot(nullptr) {}

        // Returns max depth from two roots
        size_t max() const noexcept
        {
            const int left_depth = leftRoot ? leftRoot->max() : 0;
            const int right_depth = rightRoot ? rightRoot->max() : 0;

            return (left_depth > right_depth ? left_depth : right_depth) + 1;
        }

        virtual ~Node() = default;
    };

    // Main node (root of binary tree)
    shared_ptr<Node> root;

    // For multiple use certainNode() method
    static int counter;

protected:
    // Generating random string and returns it
    // Hint: You must declare at the top following line:
    // #define GENERATE_ALL_SYMBOLS to generate string consisting of all symbols
    // or
    // #define GENERATE_ONLY_DIGITS to generate string consisting of only digits
    string generateRandomString(const size_t &) const;

    // Returns count of levels (nodes) of binary tree
    inline uint count(shared_ptr<Node> node) const
    {
        return (node == nullptr) ? 0U : (1U + count(node->leftRoot) + count(node->rightRoot));
    }

    struct cell_display
    {
        string str{""};
        bool flag{false};

        // Ctors
        explicit cell_display() : flag(false) {}
        explicit cell_display(const string &str) : str(str), flag(true) {}
    };

    /* Builds a vector of vectors of cell_display structs
    each vector of cell_display structs represents one row, starting at the root */
    vector<vector<struct cell_display>> getRowDisplay(void) const noexcept;

    /* Takes the vector of rows of cell_display structs
    generated by get_row_display and formats it into a test representation
    as a vector of strings */
    vector<string> rowFormat(const vector<vector<struct cell_display>> &) const;

    /* Trims an equal number of space characters from
    the beginning of each string in the vector.
    At least one string in the vector will end up beginning
    with no space characters. */
    static void trimRows(vector<string> &);

    // Turns int number to string for splitting on digits for check -st, -nd, -rd and -th postfixes of digits
    string transformNumber(const int &) const noexcept;

    // Adding node to the binary tree
    virtual void addNode(const string &, shared_ptr<Node> &);

    // Returns certain node by node number
    shared_ptr<Node> certainNode(shared_ptr<Node> &, const int &) const;

    // Returns node if value exists in this binary tree
    shared_ptr<Node> certainNode(shared_ptr<Node> &, const string &) const;

    // Returns number of node if value exists in this binary tree
    uint searchNodeNumberByValue(shared_ptr<Node> &, const string &) const;

    // Returns count of branches of certain node
    uint branches(shared_ptr<Node> &, const int &) const;

    // Returns minimal node in binary tree (lower left element)
    // Non-recursive function
    shared_ptr<Node> minValue(shared_ptr<Node> &) const;

    // Returns maximal element in binary tree (lower right element)
    // Recursive function
    shared_ptr<Node> maxValue(shared_ptr<Node> &) const;

    // Returns previous node by node number
    static shared_ptr<Node> previousNode(shared_ptr<Node> &, const int &);

    // Returns next node
    static shared_ptr<Node> nextNode(shared_ptr<Node> &, const int &);

    // Removes node from binary tree by value
    shared_ptr<Node> removeNodeByValue(shared_ptr<Node>, const string &);

public:
    // Zero-argument, default ctor
    explicit BinaryTree() : root(nullptr) {}

    // Ctor with main param (it is also copy ctor)
    explicit BinaryTree(const BinaryTree *&binary_tree)
    {
        root = binary_tree->root;
    }

    // Assignment operator
    BinaryTree &operator=(const BinaryTree *&);

    // Getter for max depth
    inline size_t getMaxDepth() const { return root ? root->max() : 0; }

    // Printing binary tree
    void show(void) const;

    // Adding node to tree
    virtual void addNode(const string &value) final
    {
        addNode(value, root);
    }

    // Filling binary tree with random data
    void fillRandomData(const size_t &);

    // Printing count of nodes
    void printCountOfNodes() const;

    // Printing branches of certain node (keep in mind that the countdown starts from 0)
    void printBranchesOfCertainNode(const int &);

    // Printing value of certain node. Searching by node number
    void printValueByNode(const int &);

    // Printing node with searching by value
    void printNodeByValue(const string &);

    // Printing min value from binary tree
    void searchMin(void);

    // Printing max value from binary tree
    void searchMax(void);

    // Removes element in binary tree by value
    void removeNode(const string &);

    // Virtual destructor
    virtual ~BinaryTree() = default;
};
